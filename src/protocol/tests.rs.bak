#[cfg(test)]
mod tests {
    use crate::protocol::handshake::*;
    use crate::protocol::message::Message;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_timestamp_verification() {
        // Current timestamp should be valid
        let timestamp = current_timestamp();
        assert!(verify_timestamp(timestamp, 30));
        
        // Timestamp from the future (beyond tolerance) should be invalid
        assert!(!verify_timestamp(timestamp + 6000, 30));
        
        // Timestamp too old should be invalid
        assert!(!verify_timestamp(timestamp - 31000, 30));
        
        // Timestamp within threshold should be valid
        assert!(verify_timestamp(timestamp - 29000, 30));
    }
    
    #[test]
    fn test_nonce_hashing() {
        let nonce = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
        let hash1 = hash_nonce(&nonce);
        let hash2 = hash_nonce(&nonce);
        
        // Same nonce should produce same hash
        assert_eq!(hash1, hash2);
        
        let different_nonce = [16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
        let hash3 = hash_nonce(&different_nonce);
        
        // Different nonce should produce different hash
        assert_ne!(hash1, hash3);
    }

    #[test]
    fn test_secure_handshake_flow() {
        // Step 1: Client initiates handshake
        let init_message = client_secure_handshake_init();
        
        // Extract client data
        let (client_pub_key, timestamp, client_nonce) = match init_message {
            Message::SecureHandshakeInit { pub_key, timestamp, nonce } => (pub_key, timestamp, nonce),
            _ => panic!("Expected SecureHandshakeInit message"),
        };
        
        // Ensure timestamp is valid
        assert!(verify_timestamp(timestamp, 30));
        
        // Step 2: Server processes handshake and responds
        let server_response = server_secure_handshake_response(client_pub_key, client_nonce)
            .expect("Server response should succeed");
        
        // Extract server data
        let (server_pub_key, server_nonce, nonce_verification) = match server_response {
            Message::SecureHandshakeResponse { pub_key, nonce, nonce_verification } => 
                (pub_key, nonce, nonce_verification),
            _ => panic!("Expected SecureHandshakeResponse message"),
        };
        
        // Step 3: Client verifies server response and confirms
        let client_confirm = client_verify_handshake(
            server_pub_key, 
            server_nonce, 
            nonce_verification, 
            client_nonce
        ).expect("Client verification should succeed");
        
        // Extract client confirmation
        let confirmation_hash = match client_confirm {
            Message::SecureHandshakeConfirm { nonce_verification } => nonce_verification,
            _ => panic!("Expected SecureHandshakeConfirm message"),
        };
        
        // Step 4: Server verifies client confirmation
        assert!(server_verify_confirmation(confirmation_hash, server_nonce));
        
        // Verify shared secrets match
        let client_shared = get_client_shared_secret(server_pub_key)
            .expect("Client should have shared secret");
            
        let server_shared = get_server_shared_secret(client_pub_key)
            .expect("Server should have shared secret");
            
        assert_eq!(client_shared.as_bytes(), server_shared.as_bytes());
        
        // Test key derivation produces consistent results
        let client_key = derive_secure_key(&client_shared, &client_nonce, &server_nonce);
        let server_key = derive_secure_key(&server_shared, &client_nonce, &server_nonce);
        assert_eq!(client_key, server_key);
    }

    #[test]
    fn test_replay_attack_prevention() {
        // Get initial client message
        let init_message = client_secure_handshake_init();
        
        // Extract client data
        let (client_pub_key, timestamp, client_nonce) = match init_message {
            Message::SecureHandshakeInit { pub_key, timestamp, nonce } => (pub_key, timestamp, nonce),
            _ => panic!("Expected SecureHandshakeInit message"),
        };
        
        // Wait for a moment to simulate time passing
        thread::sleep(Duration::from_millis(1100));
        
        // Modify timestamp to be too old
        let old_timestamp = timestamp - 31000;
        
        // This simulates a replay attack
        let replayed_message = Message::SecureHandshakeInit {
            pub_key: client_pub_key,
            timestamp: old_timestamp,
            nonce: client_nonce,
        };
        
        // Verify that the timestamp is rejected
        match replayed_message {
            Message::SecureHandshakeInit { timestamp, .. } => {
                assert!(!verify_timestamp(timestamp, 30));
            },
            _ => panic!("Wrong message type"),
        }
    }

    #[test]
    fn test_tampering_detection() {
        // Step 1: Client initiates handshake
        let init_message = client_secure_handshake_init();
        
        // Extract client data
        let (client_pub_key, timestamp, client_nonce) = match init_message {
            Message::SecureHandshakeInit { pub_key, timestamp, nonce } => (pub_key, timestamp, nonce),
            _ => panic!("Expected SecureHandshakeInit message"),
        };
        
        // Step 2: Server processes handshake and responds
        let server_response = server_secure_handshake_response(client_pub_key, client_nonce)
            .expect("Server response should succeed");
        
        // Extract server data
        let (server_pub_key, server_nonce, _) = match server_response {
            Message::SecureHandshakeResponse { pub_key, nonce, nonce_verification } => 
                (pub_key, nonce, nonce_verification),
            _ => panic!("Expected SecureHandshakeResponse message"),
        };
        
        // Simulate tampering with incorrect verification
        let tampered_nonce_verification = [0u8; 32];
        
        // This should fail verification
        let result = client_verify_handshake(
            server_pub_key,
            server_nonce,
            tampered_nonce_verification,
            client_nonce
        );
        
        assert!(result.is_err());
    }
}
